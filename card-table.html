<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Card Table</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #0f4c3a;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      .table {
        width: 100vw;
        height: 100vh;
        background: #0f4c3a;
        position: relative;
        border-radius: 50px;
        border: 10px solid #8b4513;
        transform-origin: center center;
        transition: transform 0.3s ease;
      }

      .zone {
        position: absolute;
        border: 2px dashed rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        width: 200px;
        height: 200px;
        cursor: move;
        resize: both;
        overflow: auto;
        z-index: 0;
      }

      .zone.layered {
        background: #6b4a2b;
        border-color: #4a2d16;
      }

      .layer-highlight {
        position: absolute;
        border: 2px dashed yellow;
        background: rgba(255, 255, 0, 0.2);
        pointer-events: none;
        display: none;
        z-index: 5;
      }

      .zone-label {
        position: absolute;
        top: 5px;
        left: 5px;
        color: #fff;
        font-size: 12px;
        font-weight: bold;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      }

      .zone-options {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #333;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 14px;
        z-index: 10;
        color: #333;
        font-weight: bold;
      }

      /* Show zone options only while in board edit mode */
      .board-edit-mode .zone:hover .zone-options {
        display: flex;
      }

      .zone-options:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      .card {
        position: absolute;
        border-radius: 8px;
        cursor: move;
        user-select: none;
        transition: transform 0.2s ease;
        box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: #333;
        border: 2px solid #333;
      }

      .card:hover {
        transform: scale(1.05);
      }

      .card.dragging {
        /* transform handled dynamically */
      }

      .card.itsybitsy {
        width: 45px; /* 1.25" at 72 DPI */
        height: 63px; /* 1.75" at 72 DPI */
      }

      .card.teeny {
        width: 63px; /* 1.25" at 72 DPI */
        height: 90px; /* 1.75" at 72 DPI */
      }

      .card.tiny {
        width: 90px; /* 1.25" at 72 DPI */
        height: 126px; /* 1.75" at 72 DPI */
      }

      .card.small {
        width: 126px; /* 1.75" at 72 DPI */
        height: 180px; /* 2.5" at 72 DPI */
      }

      .card.big {
        width: 180px; /* 2.5 inches at 72 DPI */
        height: 252px; /* 3.5 inches at 72 DPI */
      }

      .card.huge {
        width: 252px; /* 3.5 inches at 72 DPI */
        height: 360px; /* 5 inches at 72 DPI */
      }

      .card.giant {
        width: 360px; /* 5 inches at 72 DPI */
        height: 504px; /* 7 inches at 72 DPI */
      }

      .card.front {
        background: white;
      }

      .card.back {
        background: black;
        color: white;
      }

      /* AGE SYMBOL - TOP LEFT */
      .card-age {
        position: absolute;
        top: 5px;
        left: 5px;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        z-index: 5;
      }

      /* POINTS NUMBER - BELOW AGE SYMBOL */
      .card-points {
        position: absolute;
        top: 28px;
        left: 5px;
        width: 18px;
        height: 18px;
        background: #333;
        border: 1px solid #666;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        color: white;
        z-index: 5;
      }

      .card.back .card-age,
      .card.back .card-points {
        display: none;
      }

      .card.back .card-slot {
        display: none;
      }

      .card-options {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #333;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 14px;
        z-index: 10;
        transition: all 0.2s ease;
        color: #333;
        font-weight: bold;
      }

      .flip-btn,
      .rotate-btn {
        position: absolute;
        top: 5px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #333;
        border-radius: 5px;
        padding: 2px 5px;
        font-size: 10px;
        cursor: pointer;
        z-index: 10;
        display: none;
      }

      .flip-btn {
        right: 5px;
      }
      .rotate-btn {
        right: 30px;
      }

      .card:hover .flip-btn,
      .card:hover .rotate-btn {
        display: block;
      }

      .board-edit-mode .flip-btn,
      .board-edit-mode .rotate-btn {
        display: none !important;
      }

      .card.back .card-options {
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid #333;
        box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
      }

      /* Show card options only while in board edit mode */
      .board-edit-mode .card:hover .card-options {
        display: flex;
      }

      .card-options:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      .options-menu {
        position: absolute;
        top: 25px;
        right: 0;
        background: white;
        border: 2px solid #333;
        border-radius: 5px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        padding: 0;
        min-width: 100px;
        z-index: 1001;
        display: none;
      }

      .card.back .options-menu {
        box-shadow:
          0 4px 12px rgba(255, 255, 255, 0.3),
          0 2px 6px rgba(0, 0, 0, 0.8);
        border: 2px solid #666;
      }

      .options-menu.show {
        display: block;
      }

      .menu-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 12px;
        border-bottom: 1px solid #eee;
        transition: background-color 0.2s ease;
      }

      .menu-item:last-child {
        border-bottom: none;
      }

      .menu-item:hover {
        background-color: #f0f0f0;
      }

      .controls {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
      }

      .board-edit-mode #controls {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 10px;
      }

      .zoom-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 10px;
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .zoom-btn {
        width: 35px;
        height: 35px;
        background: #2196f3;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .zoom-btn:hover {
        background: #1976d2;
      }

      .zoom-level {
        font-size: 12px;
        color: #333;
        min-width: 40px;
        text-align: center;
      }

      .btn {
        margin: 5px;
        padding: 10px 15px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      .btn:hover {
        background: #45a049;
      }

      .add-card-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }

      .add-card-modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        text-align: center;
        max-width: 300px;
      }

      .modal-content h3 {
        margin-top: 0;
        color: #333;
      }

      .size-options {
        margin: 20px 0;
      }

      .size-btn {
        margin: 5px;
        padding: 10px 20px;
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .size-btn:hover {
        background: #e0e0e0;
        border-color: #bbb;
      }

      .size-btn.selected {
        background: #4caf50;
        color: white;
        border-color: #45a049;
      }

      .points-options {
        margin: 20px 0;
      }

      .points-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .points-btn {
        padding: 8px;
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
      }

      .points-btn:hover {
        background: #e0e0e0;
        border-color: #bbb;
      }

      .points-btn.selected {
        background: #2196f3;
        color: white;
        border-color: #1976d2;
      }

      .age-options {
        margin: 20px 0;
      }

      .age-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .age-btn {
        padding: 8px 12px;
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
        font-size: 12px;
      }

      .age-btn:hover {
        background: #e0e0e0;
        border-color: #bbb;
      }

      .age-btn.selected {
        background: #ff9800;
        color: white;
        border-color: #f57c00;
      }

      .modal-buttons {
        margin-top: 20px;
      }

      .modal-btn {
        margin: 0 5px;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }

      .modal-btn.create {
        background: #4caf50;
        color: white;
      }

      .modal-btn.create:hover {
        background: #45a049;
      }

      .modal-btn.cancel {
        background: #f44336;
        color: white;
      }

      .card-slot {
        position: absolute;
        border: 3px dashed;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        pointer-events: none;
        z-index: 1;
        transition: transform 0.2s ease;
      }

      .card-slot.haven {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
      }

      .card-slot.prey {
        border-color: #ff4444;
        background: rgba(255, 68, 68, 0.1);
      }

      .card-slot.highlight {
        background: rgba(76, 175, 80, 0.3);
        border-width: 4px;
      }

      .card-slot.edit-mode {
        pointer-events: auto;
        border-width: 4px;
        background: rgba(255, 255, 255, 0.3);
      }

      .card.edit-mode {
        border: 3px solid #2196f3;
        background: rgba(33, 150, 243, 0.05);
        cursor: default;
      }

      .card.edit-mode .card-slot {
        pointer-events: auto;
        border-width: 4px;
      }

      .slot-edit-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 16px;
        height: 16px;
        background: #2196f3;
        color: white;
        border: 1px solid #1976d2;
        border-radius: 50%;
        font-size: 10px;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }

      .card.edit-mode .slot-edit-btn {
        display: flex;
      }

      .slot-edit-controls {
        position: absolute;
        top: -40px;
        left: 0;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 8px;
        display: none;
        gap: 5px;
        align-items: center;
        z-index: 1000;
        white-space: nowrap;
        font-size: 12px;
      }

      .slot-edit-controls.show {
        display: flex;
      }

      .slot-control {
        background: #f0f0f0;
        border: 1px solid #ccc;
        padding: 2px 6px;
        border-radius: 3px;
        cursor: pointer;
        user-select: none;
      }

      .slot-control:hover {
        background: #e0e0e0;
      }

      .slot-control:active {
        background: #d0d0d0;
      }

      .resize-handles {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .resize-handle {
        position: absolute;
        width: 8px;
        height: 8px;
        background: #2196f3;
        border: 1px solid #1976d2;
        border-radius: 2px;
        pointer-events: auto;
        cursor: nw-resize;
      }

      .resize-handle.se {
        bottom: -4px;
        right: -4px;
        cursor: se-resize;
      }

      .resize-handle.sw {
        bottom: -4px;
        left: -4px;
        cursor: sw-resize;
      }

      .resize-handle.ne {
        top: -4px;
        right: -4px;
        cursor: ne-resize;
      }

      .resize-handle.nw {
        top: -4px;
        left: -4px;
        cursor: nw-resize;
      }

      .slot-options {
        margin: 20px 0;
      }

      .slot-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .slot-btn {
        padding: 8px 12px;
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: bold;
        font-size: 12px;
      }

      .slot-btn:hover {
        background: #e0e0e0;
        border-color: #bbb;
      }

      .slot-btn.selected {
        background: #9c27b0;
        color: white;
        border-color: #7b1fa2;
      }
    </style>
  </head>
  <body>
    <div class="table" id="table">
      <!-- Cards will be added here -->
    </div>

    <div class="controls" id="controls">
      <button class="btn" id="editModeBtn" onclick="toggleBoardEditMode()">
        Enter Edit Mode
      </button>
      <div id="editControls" style="display: none">
        <button class="btn" onclick="showAddCardModal()">Add Card</button>
        <button class="btn" onclick="addZone()">Add Zone</button>
        <button class="btn" onclick="saveSetup()">Save Setup</button>
        <button class="btn" onclick="clearTable()">Clear Table</button>
      </div>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
      <div class="zoom-level" id="zoomLevel">100%</div>
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
      <button
        class="zoom-btn"
        onclick="resetZoom()"
        title="Reset Zoom"
        style="font-size: 14px"
      >
        ⌂
      </button>
    </div>

    <!-- Add Card Modal -->
    <div class="add-card-modal" id="addCardModal">
      <div class="modal-content">
        <h3>Add New Card</h3>

        <div class="size-options">
          <label><strong>Card Size:</strong></label>
          <div
            style="
              margin-top: 10px;
              display: grid;
              grid-template-columns: repeat(3, 1fr);
              gap: 8px;
            "
          >
            <div class="size-btn selected" data-size="tiny">Tiny</div>
            <div class="size-btn" data-size="small">Small</div>
            <div class="size-btn" data-size="big">Big</div>
            <div class="size-btn" data-size="huge">Huge</div>
            <div class="size-btn" data-size="giant">Giant</div>
          </div>
        </div>

        <div class="points-options">
          <label><strong>Points (optional):</strong></label>
          <div class="points-grid">
            <div class="points-btn selected" data-points="">None</div>
            <div class="points-btn" data-points="1">1</div>
            <div class="points-btn" data-points="2">2</div>
            <div class="points-btn" data-points="3">3</div>
            <div class="points-btn" data-points="4">4</div>
            <div class="points-btn" data-points="5">5</div>
            <div class="points-btn" data-points="6">6</div>
            <div class="points-btn" data-points="7">7</div>
          </div>
        </div>

        <div class="age-options">
          <label><strong>Age (optional):</strong></label>
          <div class="age-grid">
            <div class="age-btn selected" data-age="">None</div>
            <div class="age-btn" data-age="invertebrates">🐚 Invertebrates</div>
            <div class="age-btn" data-age="dinosaurs">🦖 Dinosaurs</div>
            <div class="age-btn" data-age="mammals">🦣 Mammals</div>
          </div>
        </div>

        <div class="slot-options">
          <label><strong>Card Slots (for Small+ cards):</strong></label>
          <div class="slot-grid">
            <div class="slot-btn selected" data-slots="none">None</div>
            <div class="slot-btn" data-slots="haven">Haven</div>
            <div class="slot-btn" data-slots="prey">Prey</div>
            <div class="slot-btn" data-slots="both">Both</div>
          </div>
        </div>

        <div class="modal-buttons">
          <button class="modal-btn create" onclick="createCardFromModal()">
            Create Card
          </button>
          <button class="modal-btn cancel" onclick="hideAddCardModal()">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <script>
      let cardCounter = 0;
      let draggedCard = null;
      let stacks = [];
      let currentZoom = 1.0;
      let slotRelationships = {}; // Track which cards are in which slots
      let zoneCounter = 0;
      let zones = [];
      let zoneCards = {};
      let boardEditMode = false;

      function toggleBoardEditMode() {
        if (boardEditMode) {
          exitBoardEditMode();
        } else {
          enterBoardEditMode();
        }
      }

      function enterBoardEditMode() {
        boardEditMode = true;
        document.body.classList.add("board-edit-mode");
        const editControls = document.getElementById("editControls");
        if (editControls) editControls.style.display = "block";
        const btn = document.getElementById("editModeBtn");
        if (btn) btn.textContent = "Exit Edit Mode";
        document.querySelectorAll(".card").forEach((card) => {
          card.classList.add("edit-mode");
          updateCardMenu(card);
        });
      }

      function exitBoardEditMode() {
        boardEditMode = false;
        document.body.classList.remove("board-edit-mode");
        const editControls = document.getElementById("editControls");
        if (editControls) editControls.style.display = "none";
        const btn = document.getElementById("editModeBtn");
        if (btn) btn.textContent = "Enter Edit Mode";
        document.querySelectorAll(".card").forEach((card) => {
          card.classList.remove("edit-mode");
          card
            .querySelectorAll(".slot-edit-controls")
            .forEach((ctrl) => ctrl.classList.remove("show"));
          card
            .querySelectorAll(".card-slot")
            .forEach((slot) => slot.classList.remove("edit-mode"));
          updateCardMenu(card);
        });
        hideAllMenus();
      }

      function bringCardToFront(card) {
        const cards = document.querySelectorAll(".card");
        let maxZ = 0;
        cards.forEach((c) => {
          const z = parseInt(c.style.zIndex) || 0;
          if (z > maxZ) maxZ = z;
        });
        const newZ = maxZ + 1;
        card.style.zIndex = newZ;

        // Ensure any cards slotted into this card come along for the ride
        Object.keys(slotRelationships).forEach((cardId) => {
          const relationship = slotRelationships[cardId];
          if (relationship.hostCard === card.id) {
            const slottedCard = document.getElementById(cardId);
            if (slottedCard) {
              slottedCard.style.zIndex = newZ + 1;
            }
          }
        });
      }

      function addCard(
        size,
        points = null,
        age = null,
        slots = null,
        customId = null,
      ) {
        const table = document.getElementById("table");
        const card = document.createElement("div");

        card.className = `card ${size} front`;
        let newId;
        if (customId) {
          newId = customId;
          const num = parseInt(customId.split("-")[1]);
          if (!isNaN(num)) {
            cardCounter = Math.max(cardCounter, num);
          }
        } else {
          cardCounter++;
          newId = `card-${cardCounter}`;
        }
        card.id = newId;
        card.style.left = Math.random() * (table.clientWidth - 200) + "px";
        card.style.top = Math.random() * (table.clientHeight - 200) + "px";
        card.style.zIndex = cardCounter;
        card.dataset.size = size;
        card.dataset.flipped = "false";
        card.dataset.points = points || "";
        card.dataset.age = age || "";
        card.dataset.slots = slots || "";
        card.dataset.rotation = "0";
        card.style.transform = "rotate(0deg)";

        // Create card text content
        const cardText = document.createElement("div");
        cardText.className = "card-text";
        cardText.textContent = `${size.toUpperCase()} ${cardCounter}`;
        card.appendChild(cardText);

        // Create age display if age is specified (TOP LEFT)
        if (age) {
          const ageDisplay = document.createElement("div");
          ageDisplay.className = "card-age";
          const ageEmojis = {
            invertebrates: "🐚",
            dinosaurs: "🦖",
            mammals: "🦣",
          };
          ageDisplay.textContent = ageEmojis[age];
          card.appendChild(ageDisplay);
        }

        // Create points display if points are specified (BELOW AGE)
        if (points) {
          const pointsDisplay = document.createElement("div");
          pointsDisplay.className = "card-points";
          pointsDisplay.textContent = points;
          card.appendChild(pointsDisplay);
        }

        // Create options button
        const optionsBtn = document.createElement("div");
        optionsBtn.className = "card-options";
        optionsBtn.innerHTML = "⋯";
        optionsBtn.addEventListener("click", showOptionsMenu);

        // Create options menu
        const optionsMenu = document.createElement("div");
        optionsMenu.className = "options-menu";
        optionsBtn.appendChild(optionsMenu);

        card.appendChild(optionsBtn);

        // Flip button appears on hover
        const flipBtn = document.createElement("div");
        flipBtn.className = "flip-btn";
        flipBtn.textContent = "Flip";
        flipBtn.addEventListener("click", () => flipCard(card.id));
        card.appendChild(flipBtn);

        // Rotate button appears on hover
        const rotateBtn = document.createElement("div");
        rotateBtn.className = "rotate-btn";
        rotateBtn.textContent = "↻";
        rotateBtn.addEventListener("click", () => rotateCard(card.id));
        card.appendChild(rotateBtn);

        // Add event listeners
        card.addEventListener("mousedown", startDrag);

        // Add card to table FIRST
        table.appendChild(card);

        // THEN create slots (after card is in DOM)
        if (size !== "tiny" && slots && slots !== "none") {
          createCardSlots(card, slots);
        }

        // Ensure new cards respect current board edit mode
        if (boardEditMode) {
          card.classList.add("edit-mode");
        }

        // Update the menu content based on card state
        updateCardMenu(card);
      }

      function createCardSlots(card, slotType) {
        const cardWidth = card.offsetWidth || getCardWidth(card.dataset.size);
        const cardHeight =
          card.offsetHeight || getCardHeight(card.dataset.size);

        // Slot dimensions (for tiny cards to fit in)
        const slotWidth = 80;
        const slotHeight = 116;
        const margin = 10;

        if (slotType === "haven" || slotType === "both") {
          const havenSlot = createSlot(
            "haven",
            slotWidth,
            slotHeight,
            margin,
            margin,
            card,
          );
          if (slotType === "both") {
            havenSlot.style.left = margin + "px";
          }
          card.appendChild(havenSlot);
        }

        if (slotType === "prey" || slotType === "both") {
          const preySlot = createSlot(
            "prey",
            slotWidth,
            slotHeight,
            margin,
            margin,
            card,
          );
          if (slotType === "both") {
            preySlot.style.right = margin + "px";
            preySlot.style.left = "auto";
          } else {
            preySlot.style.left = margin + "px";
          }
          card.appendChild(preySlot);
        }
      }

      function createSlot(type, width, height, leftPos, bottomPos, parentCard) {
        if (!parentCard) return null;

        const slot = document.createElement("div");
        slot.className = `card-slot ${type}`;
        slot.style.width = width + "px";
        slot.style.height = height + "px";
        slot.style.left = leftPos + "px";
        slot.style.bottom = bottomPos + "px";
        slot.dataset.slotType = type;
        slot.dataset.maxSize = getSlotMaxSize(parentCard.dataset.size);
        slot.dataset.rotation = "0";
        slot.dataset.slotSize = "tiny"; // Default size

        // Create edit button
        const editBtn = document.createElement("div");
        editBtn.className = "slot-edit-btn";
        editBtn.innerHTML = "⚙";
        editBtn.title = "Edit Slot";
        editBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleSlotEditMode(slot);
        });

        // Create a unique ID for this slot to avoid conflicts
        const slotId = `slot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        slot.id = slotId;

        // Create edit controls with size options and rotate
        const controls = document.createElement("div");
        controls.className = "slot-edit-controls";
        controls.innerHTML = `
                <span style="font-weight: bold;">Size:</span>
                <span class="slot-control size-option selected" data-size="tiny" onclick="changeSlotSize(this, 'tiny')">Tiny</span>
                <span class="slot-control size-option" data-size="small" onclick="changeSlotSize(this, 'small')">Small</span>
                <span class="slot-control size-option" data-size="big" onclick="changeSlotSize(this, 'big')">Big</span>
                <span class="slot-control size-option" data-size="huge" onclick="changeSlotSize(this, 'huge')">Huge</span>
                <span class="slot-control size-option" data-size="giant" onclick="changeSlotSize(this, 'giant')">Giant</span>
                <span class="slot-control" onclick="rotateSlot90(this)">↻ 90°</span>
                <span class="slot-control" onclick="deleteSlot(this)">🗑</span>
                <span class="slot-control" onclick="finishSlotEdit(this)">✓</span>
            `;

        slot.appendChild(editBtn);
        slot.appendChild(controls);

        // Add drag functionality for slot positioning
        slot.addEventListener("mousedown", startSlotDrag);

        return slot;
      }

      function startSlotDrag(e) {
        // Only allow dragging if the slot is in edit mode and we're clicking on the slot itself
        if (
          !e.target.classList.contains("card-slot") ||
          !e.target.classList.contains("edit-mode")
        ) {
          return;
        }

        e.stopPropagation();
        const slot = e.target;
        const parentCard = slot.closest(".card");

        const startX = e.clientX;
        const startY = e.clientY;
        const startLeft = parseFloat(slot.style.left) || 0;
        const startBottom = parseFloat(slot.style.bottom) || 0;

        function dragSlot(e) {
          const deltaX = (e.clientX - startX) / currentZoom;
          const deltaY = (startY - e.clientY) / currentZoom; // Invert Y for bottom positioning

          let newLeft = startLeft + deltaX;
          let newBottom = startBottom + deltaY;

          // Slot dimensions
          const width = parseFloat(slot.style.width) || 80;
          const height = parseFloat(slot.style.height) || 116;

          // Parent card bounds
          const parentWidth = parentCard.clientWidth;
          const parentHeight = parentCard.clientHeight;

          // Compute slot corner points after rotation and translation
          const rotation =
            ((parseInt(slot.dataset.rotation) || 0) * Math.PI) / 180;
          const cosA = Math.cos(rotation);
          const sinA = Math.sin(rotation);
          const centerX = newLeft + width / 2;
          const centerY = newBottom + height / 2;
          const halfW = width / 2;
          const halfH = height / 2;

          const corners = [
            { dx: -halfW, dy: -halfH },
            { dx: halfW, dy: -halfH },
            { dx: -halfW, dy: halfH },
            { dx: halfW, dy: halfH },
          ].map(({ dx, dy }) => ({
            x: centerX + dx * cosA - dy * sinA,
            y: centerY + dx * sinA + dy * cosA,
          }));

          const xs = corners.map((p) => p.x);
          const ys = corners.map((p) => p.y);
          let minX = Math.min(...xs);
          let maxX = Math.max(...xs);
          let minY = Math.min(...ys);
          let maxY = Math.max(...ys);

          // Adjust position if any corner crosses the parent bounds
          let adjustX = 0;
          if (minX < 0) adjustX = -minX;
          if (maxX + adjustX > parentWidth)
            adjustX -= maxX + adjustX - parentWidth;

          let adjustY = 0;
          if (minY < 0) adjustY = -minY;
          if (maxY + adjustY > parentHeight)
            adjustY -= maxY + adjustY - parentHeight;

          newLeft += adjustX;
          newBottom += adjustY;

          slot.style.left = newLeft + "px";
          slot.style.bottom = newBottom + "px";
        }

        function stopSlotDrag() {
          document.removeEventListener("mousemove", dragSlot);
          document.removeEventListener("mouseup", stopSlotDrag);
        }

        document.addEventListener("mousemove", dragSlot);
        document.addEventListener("mouseup", stopSlotDrag);
      }

      function changeSlotSize(element, size) {
        const slot = element.closest(".card-slot");
        const controls = element.closest(".slot-edit-controls");

        // Update selection UI
        controls
          .querySelectorAll(".size-option")
          .forEach((opt) => opt.classList.remove("selected"));
        element.classList.add("selected");

        // Get new dimensions
        const dimensions = getSlotDimensions(size);
        slot.style.width = dimensions.width + "px";
        slot.style.height = dimensions.height + "px";
        slot.dataset.slotSize = size;
      }

      function getSlotDimensions(size) {
        const dimensions = {
          itsybitsy: { width: 35, height: 53 },
          teeny: { width: 53, height: 80 },
          tiny: { width: 80, height: 116 },
          small: { width: 116, height: 170 },
          big: { width: 170, height: 242 },
          huge: { width: 242, height: 350 },
          giant: { width: 350, height: 494 },
        };
        return dimensions[size] || dimensions.itsybitsy;
      }

      function rotateSlot90(element) {
        const slot = element.closest(".card-slot");
        const currentRotation = parseInt(slot.dataset.rotation) || 0;
        const newRotation = (currentRotation + 90) % 360;

        slot.dataset.rotation = newRotation;
        slot.style.transform = `rotate(${newRotation}deg)`;
      }

      function finishSlotEdit(element) {
        if (!element) return;

        const slot = element.closest(".card-slot");
        if (!slot) return;

        slot.classList.remove("edit-mode");
        const controls = slot.querySelector(".slot-edit-controls");
        if (controls) {
          controls.classList.remove("show");
        }
      }

      function deleteSlot(element) {
        const slot = element.closest(".card-slot");
        if (!slot) return;
        const card = slot.closest(".card");
        slot.remove();
        if (card) {
          updateCardSlotData(card);
          updateCardMenu(card);
        }
      }

      function updateCardSlotData(card) {
        const types = Array.from(card.querySelectorAll(".card-slot")).map(
          (s) => s.dataset.slotType,
        );
        if (types.includes("haven") && types.includes("prey")) {
          card.dataset.slots = "both";
        } else if (types.includes("haven")) {
          card.dataset.slots = "haven";
        } else if (types.includes("prey")) {
          card.dataset.slots = "prey";
        } else {
          card.dataset.slots = "";
        }
      }

      function toggleSlotEditMode(slot) {
        if (!slot) return;

        const isEditMode = slot.classList.contains("edit-mode");

        // Exit all slot edit modes first
        document.querySelectorAll(".card-slot.edit-mode").forEach((s) => {
          s.classList.remove("edit-mode");
          const controls = s.querySelector(".slot-edit-controls");
          if (controls) {
            controls.classList.remove("show");
          }
        });

        if (!isEditMode) {
          slot.classList.add("edit-mode");
          const controls = slot.querySelector(".slot-edit-controls");
          if (controls) {
            controls.classList.add("show");

            // Update size selection to match current slot
            const currentSize = slot.dataset.slotSize || "itsybitsy";
            controls.querySelectorAll(".size-option").forEach((opt) => {
              opt.classList.remove("selected");
              if (opt.dataset.size === currentSize) {
                opt.classList.add("selected");
              }
            });
          }
        }
      }

      function getCardWidth(size) {
        const sizes = { itsybitsy: 45, teeny: 63, tiny: 90, small: 116, big: 180, huge: 252, giant: 360 };
        return sizes[size] || 45;
      }

      function getCardHeight(size) {
        const sizes = {
          itsybitsy: 63,
          teeny: 90,
          tiny: 126,
          small: 170,
          big: 252,
          huge: 360,
          giant: 504,
        };
        return sizes[size] || 63;
      }

      function getSlotMaxSize(cardSize) {
        // Cards can hold slots for cards of their size or smaller
        const sizeOrder = ["itsybitsy","teeny","tiny", "small", "big", "huge", "giant"];
        const cardIndex = sizeOrder.indexOf(cardSize);
        return cardIndex;
      }

      function checkSlotHighlights() {
        if (!draggedCard) return;

        // Clear all highlights first
        document.querySelectorAll(".card-slot").forEach((slot) => {
          slot.classList.remove("highlight");
        });

        const draggedSize = getSizeIndex(draggedCard.dataset.size);
        const draggedRect = draggedCard.getBoundingClientRect();

        // Check all slots on the table
        document.querySelectorAll(".card-slot").forEach((slot) => {
          const slotCard = slot.closest(".card");
          if (slotCard === draggedCard) return; // Don't snap to own slots
          if (slotCard.dataset.flipped === "true") return; // Ignore slots on face-down cards

          // Only highlight slots that match the dragged card's size
          const slotSize = getSizeIndex(slot.dataset.slotSize);
          if (draggedSize !== slotSize) return; // Sizes must match exactly

          const slotRect = slot.getBoundingClientRect();
          if (isOverlapping(draggedRect, slotRect)) {
            slot.classList.add("highlight");
          }
        });
      }

      function updateSlottedCardPositions(hostCard) {
        // Find all cards that are slotted to this host card
        Object.keys(slotRelationships).forEach((cardId) => {
          const relationship = slotRelationships[cardId];
          if (relationship.hostCard === hostCard.id) {
            const slottedCard = document.getElementById(cardId);
            if (slottedCard) {
              // Calculate absolute position based on host card's current position
              const hostX = parseFloat(hostCard.style.left) || 0;
              const hostY = parseFloat(hostCard.style.top) || 0;

              const newX = hostX + relationship.offsetX;
              const newY = hostY + relationship.offsetY;

              slottedCard.style.left = newX + "px";
              slottedCard.style.top = newY + "px";

              // Maintain the card's rotation relative to the slot
              const rotation = relationship.rotation || 0;
              slottedCard.style.transform = `rotate(${rotation}deg)`;
            }
          }
        });
      }

      function checkForSlotSnap() {
        if (!draggedCard) return;

        // Remove any existing slot relationship when dragging starts
        if (slotRelationships[draggedCard.id]) {
          delete slotRelationships[draggedCard.id];
          // Reset card rotation when removed from slot
          draggedCard.style.transform = "";
          draggedCard.dataset.rotation = "0";
        }

        const draggedSize = getSizeIndex(draggedCard.dataset.size);
        const draggedRect = draggedCard.getBoundingClientRect();
        let bestSlot = null;
        let bestOverlap = 0;

        // Find the best overlapping slot
        document.querySelectorAll(".card-slot").forEach((slot) => {
          const slotCard = slot.closest(".card");
          if (slotCard === draggedCard) return; // Don't snap to own slots
          if (slotCard.dataset.flipped === "true") return; // Ignore slots on face-down cards

          // Only consider slots that match the dragged card's size
          const slotSize = getSizeIndex(slot.dataset.slotSize);
          if (draggedSize !== slotSize) return; // Sizes must match exactly

          const slotRect = slot.getBoundingClientRect();
          const overlap = getOverlapArea(draggedRect, slotRect);

          if (overlap > bestOverlap) {
            bestOverlap = overlap;
            bestSlot = slot;
          }
        });

        // Snap to the best slot if overlap is significant
        if (bestSlot && bestOverlap > 1000) {
          // Minimum overlap threshold
          snapToSlot(draggedCard, bestSlot);
        }
      }

      function snapToSlot(card, slot) {
        const slotCard = slot.closest(".card");
        const slotRect = slot.getBoundingClientRect();
        const tableRect = document
          .getElementById("table")
          .getBoundingClientRect();

        // Calculate the slot's position relative to its parent card
        const slotLeft = parseFloat(slot.style.left) || 0;
        const slotTop = parseFloat(slot.style.top) || 0;
        const slotBottom = parseFloat(slot.style.bottom) || 0;

        // Get parent card position
        const parentLeft = parseFloat(slotCard.style.left) || 0;
        const parentTop = parseFloat(slotCard.style.top) || 0;
        const parentHeight = slotCard.offsetHeight;

        // Calculate final position for the dragged card
        let finalX, finalY;

        if (slot.style.bottom) {
          // Positioned from bottom
          finalX = parentLeft + slotLeft;
          finalY = parentTop + parentHeight - slotBottom - slot.offsetHeight;
        } else {
          // Positioned from top
          finalX = parentLeft + slotLeft;
          finalY = parentTop + slotTop;
        }

        // Apply the snap position
        card.style.left = finalX + "px";
        card.style.top = finalY + "px";
        card.style.zIndex = parseInt(slotCard.style.zIndex) + 1;

        // Rotate the card to match the slot's rotation
        const slotRotation = parseInt(slot.dataset.rotation) || 0;
        card.style.transform = `rotate(${slotRotation}deg)`;
        card.dataset.rotation = slotRotation;

        // Track the relationship
        slotRelationships[card.id] = {
          hostCard: slotCard.id,
          slot: slot,
          offsetX: slotLeft,
          offsetY: slot.style.bottom
            ? parentHeight - slotBottom - slot.offsetHeight
            : slotTop,
          rotation: slotRotation,
        };
      }

      function hideSlotHighlights() {
        document.querySelectorAll(".card-slot").forEach((slot) => {
          slot.classList.remove("highlight");
        });
      }

      function checkLayeredZoneHighlights() {
        if (!draggedCard) return;
        document.querySelectorAll(".zone.layered").forEach((zone) => {
          let highlight = zone.querySelector(".layer-highlight");
          if (!highlight) {
            highlight = document.createElement("div");
            highlight.className = "layer-highlight";
            zone.appendChild(highlight);
          }
          const cardRect = draggedCard.getBoundingClientRect();
          const centerX = cardRect.left + cardRect.width / 2;
          const centerY = cardRect.top + cardRect.height / 2;
          const rect = zone.getBoundingClientRect();
          if (
            centerX > rect.left &&
            centerX < rect.right &&
            centerY > rect.top &&
            centerY < rect.bottom
          ) {
            const pos = getNextLayerSlotPosition(
              zone,
              draggedCard.dataset.size,
              draggedCard.dataset.rotation,
            );
            const zoneLeft = parseFloat(zone.style.left) || 0;
            const zoneTop = parseFloat(zone.style.top) || 0;
            if (pos) {
              const { w, h } = getSizeUnits(
                draggedCard.dataset.size,
                draggedCard.dataset.rotation,
              );
              highlight.style.left = pos.x - zoneLeft + "px";
              highlight.style.top = pos.y - zoneTop + "px";
              const cellW = getCardWidth("itsybitsy");
              const cellH = getCardHeight("itsybitsy");
              highlight.style.width = w * cellW + "px";
              highlight.style.height = h * cellH + "px";
              highlight.style.display = "block";
            } else {
              highlight.style.display = "none";
            }
          } else {
            highlight.style.display = "none";
          }
        });
      }

        function hideLayeredZoneHighlights() {
          document
            .querySelectorAll(".layer-highlight")
            .forEach((h) => (h.style.display = "none"));
        }

        function getSizeUnits(size, rotation = 0) {
          const cellW = getCardWidth("itsybitsy");
          const cellH = getCardHeight("itsybitsy");
          rotation = parseInt(rotation, 10) % 360;

          let w;
          let h;

            const width = getCardWidth(size);
            const height = getCardHeight(size);
            w = Math.ceil(width / cellW);
            h = Math.ceil(height / cellH);
          

          if (rotation === 90 || rotation === 270) {
            [w, h] = [h, w];
          }

          return { w, h };
        }

        function createGrid(rows, cols) {
          return Array.from({ length: rows }, () => Array(cols).fill(false));
        }

        function findSlot(grid, cols, rows, w, h) {
          for (let r = 0; r <= rows - h; r++) {
            for (let c = 0; c <= cols - w; c++) {
              let free = true;
              for (let dr = 0; dr < h && free; dr++) {
                for (let dc = 0; dc < w; dc++) {
                  if (grid[r + dr][c + dc]) {
                    free = false;
                    break;
                  }
                }
              }
              if (free) return { col: c, row: r };
            }
          }
          return null;
        }

        function isGridFull(grid) {
          return grid.every((row) => row.every((cell) => cell));
        }

        function markSlot(grid, col, row, w, h) {
          for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
              grid[row + r][col + c] = true;
            }
          }
        }

        function getNextLayerSlotPosition(zone, size, rotation = 0) {
          const left = parseFloat(zone.style.left) || 0;
          const top = parseFloat(zone.style.top) || 0;
          const cellW = getCardWidth("itsybitsy");
          const cellH = getCardHeight("itsybitsy");
          const cols = Math.max(1, Math.floor(zone.offsetWidth / cellW));
          const rows = Math.max(1, Math.floor(zone.offsetHeight / cellH));
          let layer = 0;
          let grid = createGrid(rows, cols);
          const ids = zoneCards[zone.id] || [];
          ids.forEach((id) => {
            const card = document.getElementById(id);
            if (!card) return;
            const { w, h } = getSizeUnits(card.dataset.size, card.dataset.rotation);
            let slot = findSlot(grid, cols, rows, w, h);
            if (!slot && isGridFull(grid)) {
              layer++;
              grid = createGrid(rows, cols);
              slot = findSlot(grid, cols, rows, w, h);
            }
            if (slot) markSlot(grid, slot.col, slot.row, w, h);
          });
          const rotations = [parseInt(rotation, 10) % 180, (parseInt(rotation, 10) + 90) % 180];
          for (const rot of rotations) {
            const { w, h } = getSizeUnits(size, rot);
            let slot = findSlot(grid, cols, rows, w, h);
            if (!slot && isGridFull(grid)) {
              layer++;
              grid = createGrid(rows, cols);
              slot = findSlot(grid, cols, rows, w, h);
            }
            if (slot) {
              return {
                x: left + slot.col * cellW + layer * 5,
                y: top + slot.row * cellH + layer * 5,
              };
            }
          }
          return null;
        }

      function isOverlapping(rect1, rect2) {
        return !(
          rect1.right < rect2.left ||
          rect1.left > rect2.right ||
          rect1.bottom < rect2.top ||
          rect1.top > rect2.bottom
        );
      }

      function getOverlapArea(rect1, rect2) {
        const left = Math.max(rect1.left, rect2.left);
        const right = Math.min(rect1.right, rect2.right);
        const top = Math.max(rect1.top, rect2.top);
        const bottom = Math.min(rect1.bottom, rect2.bottom);

        if (left < right && top < bottom) {
          return (right - left) * (bottom - top);
        }
        return 0;
      }

      function exitSlotEditMode(element) {
        if (!element) return;

        const controls = element.closest(".slot-edit-controls");
        if (controls) {
          controls.classList.remove("show");
        }
      }

      function getSizeIndex(size) {
        const sizeOrder = ["itsybitsy","teeny","tiny", "small", "big", "huge", "giant"];
        return sizeOrder.indexOf(size);
      }

      function showAddCardModal() {
        const modal = document.getElementById("addCardModal");
        modal.classList.add("show");

        // Reset selections
        document
          .querySelectorAll(".size-btn")
          .forEach((btn) => btn.classList.remove("selected"));
        document
          .querySelectorAll(".points-btn")
          .forEach((btn) => btn.classList.remove("selected"));
        document
          .querySelectorAll(".age-btn")
          .forEach((btn) => btn.classList.remove("selected"));
        document
          .querySelectorAll(".slot-btn")
          .forEach((btn) => btn.classList.remove("selected"));

        // Default selections
        document
          .querySelector('.size-btn[data-size="tiny"]')
          .classList.add("selected");
        document
          .querySelector('.points-btn[data-points=""]')
          .classList.add("selected");
        document
          .querySelector('.age-btn[data-age=""]')
          .classList.add("selected");
        document
          .querySelector('.slot-btn[data-slots="none"]')
          .classList.add("selected");
      }

      function hideAddCardModal() {
        const modal = document.getElementById("addCardModal");
        modal.classList.remove("show");
      }

      function createCardFromModal() {
        const selectedSize =
          document.querySelector(".size-btn.selected")?.dataset.size;
        const selectedPoints = document.querySelector(".points-btn.selected")
          ?.dataset.points;
        const selectedAge =
          document.querySelector(".age-btn.selected")?.dataset.age;
        const selectedSlots =
          document.querySelector(".slot-btn.selected")?.dataset.slots;

        if (!selectedSize) {
          alert("Please select a card size");
          return;
        }

        addCard(
          selectedSize,
          selectedPoints || null,
          selectedAge || null,
          selectedSlots || null,
        );
        hideAddCardModal();
      }

      function updateCardMenu(card) {
        if (!card) return;

        const optionsMenu = card.querySelector(".options-menu");
        if (!optionsMenu) return; // Exit safely if no options menu found

        const isFlipped = card.dataset.flipped === "true";

        let menuHTML = "";

        if (boardEditMode) {
          menuHTML += `<div class="menu-item" onclick="addSlotToCard('${card.id}', 'haven')">Add Haven Slot</div>`;
          menuHTML += `<div class="menu-item" onclick="addSlotToCard('${card.id}', 'prey')">Add Prey Slot</div>`;
          menuHTML += `<div class="menu-item" onclick="changeCardAge('${card.id}')">Change Age</div>`;
          menuHTML += `<div class="menu-item" onclick="changeCardPoints('${card.id}')">Change Points</div>`;
          if (isFlipped) {
            menuHTML += `<div class="menu-item" onclick="flipCard('${card.id}')">Turn Face Up</div>`;
          } else {
            menuHTML += `<div class="menu-item" onclick="flipCard('${card.id}')">Turn Face Down</div>`;
          }
          menuHTML += `<div class="menu-item" onclick="deleteCard('${card.id}')">Delete</div>`;
        }

        optionsMenu.innerHTML = menuHTML;
      }

      function addSlotToCard(cardId, type) {
        const card = document.getElementById(cardId);
        if (!card) return;
        if (card.dataset.size === "tiny") return;
        const slot = createSlot(type, 80, 116, 10, 10, card);
        card.appendChild(slot);
        updateCardSlotData(card);
        updateCardMenu(card);
      }

      function changeCardAge(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        const age = prompt(
          "Enter age (invertebrates, dinosaurs, mammals) or leave blank:",
        );
        card.dataset.age = age || "";
        let display = card.querySelector(".card-age");
        if (age) {
          const ageEmojis = {
            invertebrates: "🐚",
            dinosaurs: "🦖",
            mammals: "🦣",
          };
          if (!display) {
            display = document.createElement("div");
            display.className = "card-age";
            card.appendChild(display);
          }
          display.textContent = ageEmojis[age] || "";
        } else if (display) {
          display.remove();
        }
        updateCardMenu(card);
      }

      function changeCardPoints(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        const points = prompt("Enter points (blank to remove):");
        card.dataset.points = points || "";
        let display = card.querySelector(".card-points");
        if (points) {
          if (!display) {
            display = document.createElement("div");
            display.className = "card-points";
            card.appendChild(display);
          }
          display.textContent = points;
        } else if (display) {
          display.remove();
        }
        updateCardMenu(card);
      }

      function showOptionsMenu(e) {
        if (!boardEditMode) return;
        e.stopPropagation();
        e.preventDefault();

        // Hide all other open menus
        document.querySelectorAll(".options-menu").forEach((menu) => {
          menu.classList.remove("show");
        });

        const card = e.target.closest(".card");
        updateCardMenu(card);

        const menu = e.target.querySelector(".options-menu");
        if (menu) {
          menu.classList.add("show");
        }
      }

      function flipCard(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;

        const isFlipped = card.dataset.flipped === "true";
        const cardText = card.querySelector(".card-text");

        if (isFlipped) {
          card.className = card.className.replace("back", "front");
          cardText.textContent = `${card.dataset.size.toUpperCase()} ${card.id.split("-")[1]}`;
          card.dataset.flipped = "false";
        } else {
          card.className = card.className.replace("front", "back");
          if (cardText) cardText.textContent = "";
          card.dataset.flipped = "true";
        }

        updateCardMenu(card);
        hideAllMenus();
      }

      function rotateCard(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;
        const current = parseInt(card.dataset.rotation || "0", 10);
        const next = (current + 90) % 360;
        card.dataset.rotation = String(next);
        card.style.transform = `rotate(${next}deg)`;
        updateSlottedCardPositions(card);
      }

      function turnFaceDown(cardId) {
        const card = document.getElementById(cardId);
        if (!card) return;

        const isFlipped = card.dataset.flipped === "true";
        const cardText = card.querySelector(".card-text");

        // Only allow turning face down if card is face up
        if (!isFlipped) {
          card.className = card.className.replace("front", "back");
          cardText.textContent = "";
          card.dataset.flipped = "true";
        }

        updateCardMenu(card);
        // Hide menu
        hideAllMenus();
      }

      function deleteCard(cardId) {
        const card = document.getElementById(cardId);
        if (card) {
          // Remove any slot relationships involving this card
          delete slotRelationships[cardId];

          // Remove relationships where this card was the host
          Object.keys(slotRelationships).forEach((id) => {
            if (slotRelationships[id].hostCard === cardId) {
              delete slotRelationships[id];
            }
          });

          card.remove();
        }
        hideAllMenus();
      }

      function hideAllMenus() {
        document.querySelectorAll(".options-menu").forEach((menu) => {
          menu.classList.remove("show");
        });
      }

      function startDrag(e) {
        // Don't start drag if clicking on options button, flip button, or menu
        if (
          e.target.classList.contains("card-options") ||
          e.target.classList.contains("flip-btn") ||
          e.target.classList.contains("rotate-btn") ||
          e.target.classList.contains("menu-item") ||
          e.target.closest(".options-menu")
        ) {
          return;
        }

        const card = e.target.closest(".card");
        if (!card) return;

        // Don't allow dragging if a slot on this card is being edited
        if (card.querySelector(".card-slot.edit-mode")) {
          return;
        }

        const startMouseX = e.clientX;
        const startMouseY = e.clientY;
        const dragDelay = 150;
        let dragTimeout;
        let isDragging = false;

        // Store the starting position of the card
        const startCardX = parseFloat(card.style.left) || 0;
        const startCardY = parseFloat(card.style.top) || 0;

        hideAllMenus();

        dragTimeout = setTimeout(() => {
          isDragging = true;
          draggedCard = card;
          draggedCard.classList.add("dragging");
          const angle = parseInt(draggedCard.dataset.rotation || "0", 10);
          draggedCard.style.transform = `rotate(${angle}deg) scale(1.1)`;
          bringCardToFront(draggedCard);
          releaseFromZone(draggedCard);
        }, dragDelay);

        function drag(e) {
          const deltaX = Math.abs(e.clientX - startMouseX);
          const deltaY = Math.abs(e.clientY - startMouseY);
          if (!isDragging && (deltaX > 10 || deltaY > 10)) {
            clearTimeout(dragTimeout);
            isDragging = true;
            draggedCard = card;
            draggedCard.classList.add("dragging");
            const angle2 = parseInt(draggedCard.dataset.rotation || "0", 10);
            draggedCard.style.transform = `rotate(${angle2}deg) scale(1.1)`;
            bringCardToFront(draggedCard);
            releaseFromZone(draggedCard);
          }

          if (!isDragging || !draggedCard) return;

          // Keep the dragged card (and any slotted cards) on top
          bringCardToFront(draggedCard);

          // Calculate how much the mouse has moved (in screen pixels)
          const mouseDeltaX = e.clientX - startMouseX;
          const mouseDeltaY = e.clientY - startMouseY;

          // Convert the mouse movement to table coordinate movement
          const tableDeltaX = mouseDeltaX / currentZoom;
          const tableDeltaY = mouseDeltaY / currentZoom;

          // Apply the movement to the card's starting position
          let x = startCardX + tableDeltaX;
          let y = startCardY + tableDeltaY;

          // Boundary checking
          const table = document.getElementById("table");
          const tableWidth = table.clientWidth;
          const tableHeight = table.clientHeight;
          x = Math.max(0, Math.min(x, tableWidth - draggedCard.offsetWidth));
          y = Math.max(0, Math.min(y, tableHeight - draggedCard.offsetHeight));

          draggedCard.style.left = x + "px";
          draggedCard.style.top = y + "px";

          // Update positions of any slotted cards based on new host position
          updateSlottedCardPositions(draggedCard);

          checkSlotHighlights();
          checkLayeredZoneHighlights();
        }

        function stopDrag() {
          clearTimeout(dragTimeout);
          if (draggedCard) {
            const angle3 = parseInt(draggedCard.dataset.rotation || "0", 10);
            draggedCard.classList.remove("dragging");
            draggedCard.style.transform = `rotate(${angle3}deg)`;
            checkForSlotSnap();
            checkForZoneSnap(draggedCard);
            hideSlotHighlights();
            hideLayeredZoneHighlights();
            draggedCard = null;
          }
          isDragging = false;
          document.removeEventListener("mousemove", drag);
          document.removeEventListener("mouseup", stopDrag);
        }

        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", stopDrag);
      }

      function checkStackingZones() {
        if (!draggedCard) return;

        const cards = document.querySelectorAll(".card:not(.dragging)");
        const draggedSize = draggedCard.dataset.size;

        cards.forEach((card) => {
          if (card.dataset.size === draggedSize) {
            const distance = getDistance(draggedCard, card);
            if (distance < 100) {
              highlightStackZone(card);
            }
          }
        });
      }

      function highlightStackZone(card) {
        card.style.boxShadow = "0 0 20px #4CAF50";
        setTimeout(() => {
          if (card.style) card.style.boxShadow = "2px 2px 8px rgba(0,0,0,0.3)";
        }, 200);
      }

      function hideStackingZones() {
        const cards = document.querySelectorAll(".card");
        cards.forEach((card) => {
          card.style.boxShadow = "2px 2px 8px rgba(0,0,0,0.3)";
        });
      }

      function checkForStacking() {
        if (!draggedCard) return;

        const cards = document.querySelectorAll(".card:not(.dragging)");
        const draggedSize = draggedCard.dataset.size;

        cards.forEach((card) => {
          if (card.dataset.size === draggedSize) {
            const distance = getDistance(draggedCard, card);
            if (distance < 50) {
              stackCards(draggedCard, card);
            }
          }
        });
      }

      function stackCards(movingCard, targetCard) {
        const targetRect = targetCard.getBoundingClientRect();
        const tableRect = document
          .getElementById("table")
          .getBoundingClientRect();

        movingCard.style.left = targetRect.left - tableRect.left + 5 + "px";
        movingCard.style.top = targetRect.top - tableRect.top - 5 + "px";
        movingCard.style.zIndex = parseInt(targetCard.style.zIndex) + 1;

        movingCard.style.transform = "rotate(-2deg)";
        setTimeout(() => {
          if (movingCard.style) movingCard.style.transform = "";
        }, 300);
      }

      function createZoneElement(id, left, top, width, height, size) {
        const zone = document.createElement("div");
        zone.className = "zone";
        zone.id = id;
        zone.style.left = left || "100px";
        zone.style.top = top || "100px";
        zone.style.width = width || "200px";
        zone.style.height = height || "200px";

        const label = document.createElement("div");
        label.className = "zone-label";
        zone.appendChild(label);

        const optionsBtn = document.createElement("div");
        optionsBtn.className = "zone-options";
        optionsBtn.innerHTML = "⋯";
        optionsBtn.addEventListener("click", showZoneOptionsMenu);
        const optionsMenu = document.createElement("div");
        optionsMenu.className = "options-menu";
        optionsBtn.appendChild(optionsMenu);
        zone.appendChild(optionsBtn);

        zone.addEventListener("mousedown", startZoneDrag);
        document.getElementById("table").appendChild(zone);
        zones.push(zone);
        zoneCards[id] = zoneCards[id] || [];
        if (size) setZoneSize(id, size);
        return zone;
      }

      function addZone() {
        zoneCounter++;
        const id = `zone-${zoneCounter}`;
        createZoneElement(id);
      }

      function startZoneDrag(e) {
        if (
          e.target.classList.contains("zone-options") ||
          e.target.closest(".options-menu")
        ) {
          return;
        }
        const zone = e.target.closest(".zone");
        if (!zone) return;
        const startX = e.clientX;
        const startY = e.clientY;
        const startLeft = parseFloat(zone.style.left) || 0;
        const startTop = parseFloat(zone.style.top) || 0;

        function drag(ev) {
          const dx = (ev.clientX - startX) / currentZoom;
          const dy = (ev.clientY - startY) / currentZoom;
          zone.style.left = startLeft + dx + "px";
          zone.style.top = startTop + dy + "px";
          updateZoneStack(zone);
        }

        function stop() {
          document.removeEventListener("mousemove", drag);
          document.removeEventListener("mouseup", stop);
        }

        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", stop);
      }

      function updateZoneStack(zone) {
        if (zone.dataset.layered === "true") {
          updateLayeredStack(zone);
          return;
        }
        const ids = zoneCards[zone.id] || [];
        const left = parseFloat(zone.style.left) || 0;
        const top = parseFloat(zone.style.top) || 0;
        ids.forEach((id, index) => {
          const card = document.getElementById(id);
          if (card) {
            card.style.left = left + 10 + index * 5 + "px";
            card.style.top = top + 10 + index * 5 + "px";
            card.style.zIndex = 1000 + index;
          }
        });
      }

      function updateLayeredStack(zone) {
        const ids = zoneCards[zone.id] || [];
        const left = parseFloat(zone.style.left) || 0;
        const top = parseFloat(zone.style.top) || 0;
        const cellW = getCardWidth("itsybitsy");
        const cellH = getCardHeight("itsybitsy");
        const cols = Math.max(1, Math.floor(zone.offsetWidth / cellW));
        const rows = Math.max(1, Math.floor(zone.offsetHeight / cellH));
        let layer = 0;
        let grid = createGrid(rows, cols);
        const placed = [];
        ids.forEach((id) => {
          const card = document.getElementById(id);
          if (!card) return;
          let rotation = parseInt(card.dataset.rotation || "0", 10);
          const orientations = [rotation % 180, (rotation + 90) % 180];
          let chosen = null;
          for (const rot of orientations) {
            const dims = getSizeUnits(card.dataset.size, rot);
            let slot = findSlot(grid, cols, rows, dims.w, dims.h);
            if (!slot) {
              if (isGridFull(grid)) {
                layer++;
                grid = createGrid(rows, cols);
                slot = findSlot(grid, cols, rows, dims.w, dims.h);
              }
            }
            if (slot) {
              chosen = { slot, dims, rot };
              break;
            }
          }
          if (!chosen) {
            delete card.dataset.zone;
            return;
          }
          markSlot(grid, chosen.slot.col, chosen.slot.row, chosen.dims.w, chosen.dims.h);
          let appliedRotation = rotation;
          if (chosen.rot !== rotation % 180) {
            appliedRotation = (rotation + 90) % 360;
          }
          card.dataset.rotation = String(appliedRotation);
          card.style.transform = `rotate(${appliedRotation}deg)`;
          card.style.left = left + chosen.slot.col * cellW + layer * 5 + "px";
          card.style.top = top + chosen.slot.row * cellH + layer * 5 + "px";
          card.style.zIndex = 1000 + placed.length;
          card.classList.add("back");
          card.classList.remove("front");
          card.dataset.flipped = "true";
          placed.push(id);
        });
        zoneCards[zone.id] = placed;
      }

      function releaseFromZone(card) {
        const zoneId = card.dataset.zone;
        if (zoneId && zoneCards[zoneId]) {
          zoneCards[zoneId] = zoneCards[zoneId].filter((id) => id !== card.id);
          delete card.dataset.zone;
          const zone = document.getElementById(zoneId);
          if (zone) updateZoneStack(zone);
        }
      }

      function toggleLayeredZone(zoneId) {
        const zone = document.getElementById(zoneId);
        if (!zone) return;
        if (zone.dataset.layered === "true") {
          delete zone.dataset.layered;
          zone.classList.remove("layered");
        } else {
          zone.dataset.layered = "true";
          zone.classList.add("layered");
        }
        updateZoneStack(zone);
        hideAllMenus();
      }

      function checkForZoneSnap(card) {
        const cardRect = card.getBoundingClientRect();
        const centerX = cardRect.left + cardRect.width / 2;
        const centerY = cardRect.top + cardRect.height / 2;
        zones.forEach((zone) => {
          const rect = zone.getBoundingClientRect();
          if (
            centerX > rect.left &&
            centerX < rect.right &&
            centerY > rect.top &&
            centerY < rect.bottom
          ) {
            const allowed = zone.dataset.size;
            if (
              zone.dataset.layered === "true" ||
              !allowed ||
              allowed === card.dataset.size
            ) {
              if (zone.dataset.layered === "true") {
                const pos = getNextLayerSlotPosition(
                  zone,
                  card.dataset.size,
                  card.dataset.rotation,
                );
                if (!pos) return;
              }
              if (!zoneCards[zone.id]) zoneCards[zone.id] = [];
              if (!zoneCards[zone.id].includes(card.id)) {
                zoneCards[zone.id].push(card.id);
              }
              card.dataset.zone = zone.id;
              updateZoneStack(zone);
            }
          }
        });
      }

      function updateZoneMenu(zone) {
        if (!zone) return;
        const menu = zone.querySelector(".options-menu");
        if (!menu) return;
        const sizes = ["tiny", "small", "big", "huge", "giant"];
        let html = `<div class="menu-item" onclick="toggleLayeredZone('${zone.id}')">Toggle Omni Stack</div>`;
        html += sizes
          .map((s) => {
            const name = s.charAt(0).toUpperCase() + s.slice(1);
            return `<div class="menu-item" onclick="setZoneSize('${zone.id}', '${s}')">${name}</div>`;
          })
          .join("");
        html += `<div class="menu-item" onclick="deleteZone('${zone.id}')">Delete Zone</div>`;
        menu.innerHTML = html;
      }

      function showZoneOptionsMenu(e) {
        e.stopPropagation();
        e.preventDefault();
        hideAllMenus();
        const zone = e.target.closest(".zone");
        updateZoneMenu(zone);
        const menu = e.target.querySelector(".options-menu");
        if (menu) {
          menu.classList.add("show");
        }
      }

      function setZoneSize(zoneId, size) {
        const zone = document.getElementById(zoneId);
        if (!zone) return;
        zone.dataset.size = size;
        const label = zone.querySelector(".zone-label");
        if (label) label.textContent = size.toUpperCase();
        zone.style.width = getCardWidth(size) + "px";
        zone.style.height = getCardHeight(size) + "px";
        const ids = zoneCards[zoneId] || [];
        ids.slice().forEach((id) => {
          const card = document.getElementById(id);
          if (card && card.dataset.size !== size) {
            releaseFromZone(card);
          }
        });
        updateZoneStack(zone);
        hideAllMenus();
      }

      function deleteZone(zoneId) {
        const zone = document.getElementById(zoneId);
        if (!zone) return;
        const ids = zoneCards[zoneId] || [];
        ids.forEach((id) => {
          const card = document.getElementById(id);
          if (card) delete card.dataset.zone;
        });
        delete zoneCards[zoneId];
        zones = zones.filter((z) => z.id !== zoneId);
        zone.remove();
        hideAllMenus();
      }

      function getDistance(card1, card2) {
        const rect1 = card1.getBoundingClientRect();
        const rect2 = card2.getBoundingClientRect();

        const centerX1 = rect1.left + rect1.width / 2;
        const centerY1 = rect1.top + rect1.height / 2;
        const centerX2 = rect2.left + rect2.width / 2;
        const centerY2 = rect2.top + rect2.height / 2;

        return Math.sqrt(
          Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2),
        );
      }

      function zoomIn() {
        currentZoom = Math.min(currentZoom + 0.1, 2.0);
        updateZoom();
      }

      function zoomOut() {
        currentZoom = Math.max(currentZoom - 0.1, 0.3);
        updateZoom();
      }

      function resetZoom() {
        currentZoom = 1.0;
        updateZoom();
      }

      function updateZoom() {
        const table = document.getElementById("table");
        table.style.transform = `scale(${currentZoom})`;

        const zoomLevel = document.getElementById("zoomLevel");
        zoomLevel.textContent = `${Math.round(currentZoom * 100)}%`;
      }

      function clearTable() {
        const table = document.getElementById("table");
        const cards = table.querySelectorAll(".card");
        cards.forEach((card) => card.remove());
        const zoneElems = table.querySelectorAll(".zone");
        zoneElems.forEach((z) => z.remove());
        cardCounter = 0;
        zoneCounter = 0;
        stacks = [];
        slotRelationships = {}; // Clear all slot relationships
        zones = [];
        zoneCards = {};
      }

      function saveSetup() {
        const state = { cards: [], zones: [] };
        document.querySelectorAll(".card").forEach((card) => {
          state.cards.push({
            id: card.id,
            size: card.dataset.size,
            points: card.dataset.points,
            age: card.dataset.age,
            slots: card.dataset.slots,
            left: card.style.left,
            top: card.style.top,
            zIndex: card.style.zIndex,
            faceDown: card.dataset.flipped === "true",
            rotation: card.style.transform,
            zone: card.dataset.zone || null,
          });
        });
        zones.forEach((zone) => {
          state.zones.push({
            id: zone.id,
            left: zone.style.left,
            top: zone.style.top,
            width: zone.style.width,
            height: zone.style.height,
            size: zone.dataset.size || null,
          });
        });
        localStorage.setItem("cardTableSetup", JSON.stringify(state));
      }

      function loadSetup() {
        const saved = localStorage.getItem("cardTableSetup");
        if (!saved) {
          addCard("tiny", 3, "invertebrates");
          addCard("big", null, "dinosaurs", "haven");
          addCard("huge", 7, "mammals", "both");
          return;
        }
        const data = JSON.parse(saved);
        data.zones.forEach((z) => {
          createZoneElement(z.id, z.left, z.top, z.width, z.height, z.size);
          const num = parseInt(z.id.split("-")[1]);
          if (!isNaN(num)) zoneCounter = Math.max(zoneCounter, num);
        });
        data.cards.forEach((c) => {
          addCard(
            c.size,
            c.points || null,
            c.age || null,
            c.slots || null,
            c.id,
          );
          const card = document.getElementById(c.id);
          card.style.left = c.left;
          card.style.top = c.top;
          card.style.zIndex = c.zIndex;
          if (c.rotation) card.style.transform = c.rotation;
          if (c.faceDown || c.flipped === "true") {
            turnFaceDown(c.id);
          }
          if (c.zone) {
            const zone = document.getElementById(c.zone);
            if (zone && (!zone.dataset.size || zone.dataset.size === c.size)) {
              if (!zoneCards[c.zone]) zoneCards[c.zone] = [];
              zoneCards[c.zone].push(c.id);
              card.dataset.zone = c.zone;
            }
          }
          const num = parseInt(c.id.split("-")[1]);
          if (!isNaN(num)) cardCounter = Math.max(cardCounter, num);
        });
        Object.keys(zoneCards).forEach((id) => {
          const zone = document.getElementById(id);
          if (zone) updateZoneStack(zone);
        });
      }

      // Modal interaction handlers
      document.addEventListener("click", function (e) {
        if (e.target.classList.contains("size-btn")) {
          document
            .querySelectorAll(".size-btn")
            .forEach((btn) => btn.classList.remove("selected"));
          e.target.classList.add("selected");
        }

        if (e.target.classList.contains("points-btn")) {
          document
            .querySelectorAll(".points-btn")
            .forEach((btn) => btn.classList.remove("selected"));
          e.target.classList.add("selected");
        }

        if (e.target.classList.contains("age-btn")) {
          document
            .querySelectorAll(".age-btn")
            .forEach((btn) => btn.classList.remove("selected"));
          e.target.classList.add("selected");
        }

        if (e.target.classList.contains("slot-btn")) {
          document
            .querySelectorAll(".slot-btn")
            .forEach((btn) => btn.classList.remove("selected"));
          e.target.classList.add("selected");
        }

        if (e.target.classList.contains("add-card-modal")) {
          hideAddCardModal();
        }
      });

      document.addEventListener("click", function (e) {
        if (
          !e.target.closest(".card-options") &&
          !e.target.closest(".zone-options") &&
          !e.target.closest(".options-menu")
        ) {
          hideAllMenus();
        }
      });

      // Scroll wheel zoom
      document.addEventListener(
        "wheel",
        function (e) {
          // Only zoom if not scrolling in a modal or other UI element
          if (
            e.target.closest(".add-card-modal") ||
            e.target.closest(".controls") ||
            e.target.closest(".zoom-controls")
          ) {
            return;
          }

          e.preventDefault();

          if (e.deltaY < 0) {
            // Scroll up = zoom in
            currentZoom = Math.min(currentZoom + 0.05, 2.0);
          } else {
            // Scroll down = zoom out
            currentZoom = Math.max(currentZoom - 0.05, 0.3);
          }

          updateZoom();
        },
        { passive: false },
      );

      loadSetup();
    </script>
  </body>
</html>
